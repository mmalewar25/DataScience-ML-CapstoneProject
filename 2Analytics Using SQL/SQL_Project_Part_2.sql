use modelcarsdb;
/*Task 1: Employee Data Analysis*/

-- 1. Find the total number of employees.
select count(employeeNumber) as total_emp from employees;
/*Interpretation- The total number of employees is 23.*/

-- 2. List all employees with their basic information.
select employeeNumber, lastName, firstName, email, jobTitle from employees;
/*Interpretation- All employees with their basic information have been listed.*/

-- 3. Count the number of employees holding each job title.
select jobTitle, count(*) from employees group by jobTitle;
/*Interpretation- The number of employees holding each job title have been displayed.*/

-- 4. Find the employees who don't have a manager (reports To is NULL).
select * from employees where reportsTo is null;
/*Interpretation- The employee who doesn't have a manager is the President.*/

-- 5. Calculate total sales generated by each sales representative.
select e.employeeNumber, e.lastName, e.firstName, sum(quantityOrdered*priceEach) as total_sales from employees e
join customers c on e.employeeNumber=c.salesRepEmployeeNumber
join orders o on c.customerNumber=o.customerNumber
join orderdetails d on o.orderNumber=d.orderNumber
where jobTitle='Sales Rep'
group by e.employeeNumber;
/*Interpretation- Total sales generated by each sales representative has been displayed.*/

-- 6. Find the most profitable sales representative based on total sales.
select e.employeeNumber, e.lastName, e.firstName, sum(quantityOrdered*priceEach) as total_sales from employees e
join customers c on e.employeeNumber=c.salesRepEmployeeNumber
join orders o on c.customerNumber=o.customerNumber
join orderdetails d on o.orderNumber=d.orderNumber
where jobTitle='Sales Rep'
group by e.employeeNumber
order by sum(quantityOrdered*priceEach) desc limit 1;
/*Interpretation- Most profitable sales representative based on total sales is Gerard Hernandez.*/

-- 7. Find the names of all employees who have sold more than the average sales amount for their office.
select e.employeeNumber, e.lastName, e.firstName, sum(quantityOrdered*priceEach) as total_sales from employees e
join customers c on e.employeeNumber=c.salesRepEmployeeNumber
join orders o on c.customerNumber=o.customerNumber
join orderdetails d on o.orderNumber=d.orderNumber
join offices f on e.officeCode=f.officeCode
group by e.employeeNumber
having sum(quantityOrdered*priceEach)>avg(quantityOrdered*priceEach);
/*Interpretation- Names of all employees who have sold more than the average sales amount for their office have been displayed.*/

/*Task 2: Order Analysis*/

-- 1. Find the average order amount for each customer.
select c.customerNumber, c.customerName, avg(quantityOrdered*priceEach) as avg_od_amt from customers c
join orders o on c.customerNumber=o.customerNumber
join orderdetails d on o.orderNumber=d.orderNumber
group by c.customerNumber
order by avg_od_amt desc;
/*Interpretation- Average order amount for each customer has been displayed.*/

-- 2. Find the number of orders placed in each month.
select month(orderDate), count(*) as no_of_orders from orders group by month(orderDate);
/*Interpretation- Number of orders placed in each month has been displayed.*/

-- 3. Identify orders that are still pending shipment (status = 'Pending').
select * from orders where status='Pending' group by orderNumber;
/*Interpretation- No orders are still pending shipment.*/

-- 4. List orders along with customer details.
select o.orderNumber, o.orderDate, o.customerNumber, c.customerName from orders o
join customers c on o.customerNumber=c.customerNumber;
/*Interpretation- All orders along with customer details have been listed.*/

-- 5. Retrieve the most recent orders (based on order date).
select orderNumber, max(orderDate) as recent_date from orders group by orderNumber order by max(orderDate) desc;
/*Interpretation- Most recent orders (based on order date) have been displayed.*/

-- 6. Calculate total sales for each order.
select orderNumber, sum(quantityOrdered*priceEach) as total_sales from orderdetails group by orderNumber;
/*Interpretation- Total sales for each order have been calculated.*/

-- 7. Find the highest-value order based on total sales.
select orderNumber, sum(quantityOrdered*priceEach) as Highest_value_order from orderdetails group by orderNumber order by sum(quantityOrdered*priceEach) desc limit 1;
/*Interpretation- Highest-value order based on total sales is orderNumber 10165.*/

-- 8. List all orders with their corresponding order details.
select * from orders;
/*Interpretation- All orders along with their corresponding order details have been listed.*/

-- 9. List the most frequently ordered products.
select p.productCode, p.productName, count(*) as order_count from orderdetails d
join products p on d.productCode=p.productCode
group by p.productCode
order by count(*) desc;
/*Interpretation- Most frequently ordered products have been listed.*/

-- 10. Calculate total revenue for each order.
select orderNumber, sum(quantityOrdered*priceEach) as total_revenue from orderdetails group by orderNumber;
/*Interpretation- Total revenue for each order have been calculated.*/

-- 11. Identify the most profitable orders based on total revenue.
select orderNumber, sum(quantityOrdered*priceEach) as total_revenue from orderdetails group by orderNumber order by sum(quantityOrdered*priceEach) desc;
/*Interpretation- Most profitable orders based on total revenue have been calculated.*/

-- 12. List all orders with detailed product information.
select orderNumber, d.productCode, productName, productLine, productScale, productVendor, productDescription from orderdetails d
join products p on d.productCode=p.productCode;
/*Interpretation- All orders with detailed product information have been listed.*/

-- 13. Identify orders with delayed shipping (shippedDate > requiredDate).
select * from orders where date(shippedDate) > date(requiredDate) group by orderNumber;
/*Interpretation- Only order with delayed shipping (shippedDate > requiredDate) is orderNumber 10165.*/

-- 14. Find the most popular product combinations within orders.
select product_combo, count(*) as order_count
from (select d.orderNumber, group_concat(d.productCode order by d.productCode separator ',') as product_combo from orderdetails d
join products p on d.productCode=p.productCode
group by d.orderNumber) as combos
group by product_combo
order by order_count desc;
/*Interpretation- Most popular product combinations within orders have been displayed.*/

-- 15. Calculate revenue for each order and identify the top 10 most profitable.
select orderNumber, sum(quantityOrdered*priceEach) as total_revenue from orderdetails group by orderNumber order by sum(quantityOrdered*priceEach) desc limit 10;
/*Interpretation- Top 10 most profitable orders based on total revenue have been calculated.*/

-- 16. Create a trigger that automatically updates a customer's credit limit after a new order is placed, reducing it by the order total.
DROP TRIGGER IF EXISTS `modelcarsdb`.`update_creditLimit`;

DELIMITER $$
USE `modelcarsdb`$$
CREATE DEFINER = CURRENT_USER TRIGGER `modelcarsdb`.`update_creditLimit` AFTER INSERT ON `orders` FOR EACH ROW
BEGIN
declare new_creditLimit decimal(10,2);
declare new_amount decimal(10,2);
select amount into new_amount from payments;
set new_creditLimit = (select creditLimit from customers where customerNumber=new.customerNumber)-new_amount;
update customers set creditLimit = new_creditLimit where customerNumber=new.customerNumber;
END$$
DELIMITER ;

insert into orderdetails values (99999, 'S18_9999', 30, 136.00, 3);
insert into orders values (99999, '2024-07-22', '2024-07-28', '2024-07-24', 'Shipped', 'confirmed', 500);
select * from customers;
select * from orders;
select * from orderdetails;
desc orders;
desc orderdetails;
/*Interpretation- This trigger automatically updates a customer's credit limit after a new order is placed, reducing it by the order total.*/

-- 17. Create a trigger that logs product quantity changes whenever an order detail is inserted or updated.
create table prod_qty_logs (id int primary key auto_increment, orderNumber int, productCode int, quantityOrdered int not null, orderDate date);
desc prod_qty_logs;

DELIMITER $$
USE `modelcarsdb`$$
CREATE DEFINER = CURRENT_USER TRIGGER `modelcarsdb`.`log_qty_changes` AFTER INSERT ON `orderdetails` FOR EACH ROW
BEGIN
declare old_qty int default null;
declare qty_change int default 0;
if (productCode is not null) then select quantityOrdered into old_qty from orderdetails where productCode=new.productCode;
end if;
set qty_change = new.quantityOrdered - ifnull (quantityOrdered,0);
insert into prod_qty_logs (orderNumber, productCode, quantityOrdered, orderDate) values (new.orderNumber, new.productCode, qty_change, curdate());
update orderdetails set quantityOrdered = quantityOrdered-qty_change where productCode=new.productCode;
END$$
DELIMITER ;

insert into orderdetails values (99999, 'S18_9999', 30, 136.00, 3);
/*Interpretation- This trigger logs product quantity changes whenever an order detail is inserted or updated.*/